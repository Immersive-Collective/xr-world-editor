<!DOCTYPE html>
<html>

<head>
    <title>WORLD</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/wcAAwAB/Deus1kAAAAASUVORK5CYII=" />
    <link rel="stylesheet" href="{{ url_for('static', filename='styles/main.css') }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body id="main-body">

<script type="importmap">
{
  "imports": {
    "three": "{{ url_for('static', filename='libs/three/build/three.module.js') }}",
    "three/addons/": "{{ url_for('static', filename='libs/three/examples/jsm/') }}",
    "gsap": "{{ url_for('static', filename='libs/gsap/index.js') }}",    
    "gsap/plugins/": "{{ url_for('static', filename='libs/gsap/') }}"    
  }
}
</script>

<script type="module">

const container = document.createElement('div');
document.body.appendChild(container);

import * as THREE from 'three';
import Stats from 'three/addons/libs/stats.module.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

import { gsap } from "gsap";
import { PixiPlugin } from "gsap/plugins/PixiPlugin.js";
import { MotionPathPlugin } from "gsap/plugins/MotionPathPlugin.js";

import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

import RAPIER from '{{ url_for('static', filename='libs/rapier3d-compat/rapier.es.js') }}';

import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";

import { XRHandModelFactory } from '{{ url_for('static', filename='libs/hands/XRHandModelFactory.js') }}';


/* Some legacy variables */


const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('/static/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);


const tronLegacyColors = {
    
    deepBlack: 0x0a0a0a,
    greyMetallic: 0x6f6f6f,
    darkGrey: 0x1c1c1c,
    
    brightBlue: 0x00d9ff,
    brightOrange: 0xff3700,
    pureWhite: 0xffffff,

    almostBlack: 0x1a1a1a,
    digitalBlue: 0x0057ff,
};



/* Teleportation - Controllers */


let world
let groundHeight = 0;
let gravity = { x: 0.0, y: -2, z: 0.0 };
let eventQueue

window.myRapierWorld
window.rigidBodies = window.rigidBodies || [];
window.threeCubes = window.threeCubes || [];


/* Controllers */

const objsToTest = [];

let hand1, hand2;
let controller1, controller2;
let controllerGrip1, controllerGrip2;

let controllers = [];
let dummyMatrix;

const handModels = {
    left: null,
    right: null,
};
let handModelFactory;
let conS = [];

let teleportMode = false;
let teleportRing;
let cameraContainer
let activeController

function generateRayTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext("2d");

    // Create a gradient that starts fading to transparent immediately
    const gradient = ctx.createLinearGradient(0, 0, 0, 64);
    gradient.addColorStop(0, "rgba(255, 0, 0, 1)"); // Fully opaque at the start
    gradient.addColorStop(0.1, "rgba(255, 0, 0, 0)"); // Start fading out almost immediately

    // The rest of the gradient is transparent
    gradient.addColorStop(1, "rgba(255, 0, 0, 0)"); // Fully transparent towards the end

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);

    return canvas;
}

function generatePointerTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;

    const ctx = canvas.getContext("2d");

    ctx.beginPath();
    ctx.arc(32, 32, 29, 0, 2 * Math.PI);
    ctx.lineWidth = 5;
    ctx.stroke();
    ctx.fillStyle = "white";
    ctx.fill();

    return canvas;
}


function getCameraPosition() {
    let renderer = magicBrush;
    let camera = magicEye;
    const cameraPosition = new THREE.Vector3();
    renderer.xr.getCamera(camera).getWorldPosition(cameraPosition);
    return cameraPosition;
}



function addBallTrajectory() {

    let renderer = magicBrush;
    let camera = magicEye;
    let scene = playground;

  // Remove existing line if any

  if (window.ballTrajectory) {
    scene.remove(window.ballTrajectory);
  }

  let cameraPosition = getCameraPosition();
  let leftHand = renderer.xr.getController(0); // 0 is usually the left hand
  let leftHandPosition = new THREE.Vector3();
  leftHand.getWorldPosition(leftHandPosition);

  // Create the line to visualize this vector
  const lineGeometry = new THREE.BufferGeometry().setFromPoints([leftHandPosition, cameraPosition]);
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
  const line = new THREE.Line(lineGeometry, lineMaterial);

  window.ballTrajectory = line;

  // Add line to the scene
  scene.add(window.ballTrajectory);

}


function initControllers() {

    let renderer = magicBrush;
    let camera = magicEye;
    let scene = playground;    


    addBallTrajectory()

    //shot.initShotLines(scene);


    const rayTexture = new THREE.CanvasTexture(generateRayTexture());
    rayTexture.needsUpdate = true;

    const material = new THREE.MeshBasicMaterial({
        map: rayTexture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.05,
    });

    const geometry = new THREE.BoxGeometry(0.005, 0.005, 20);
    geometry.translate(0, 0, -10.01);

    const uvAttribute = geometry.getAttribute("uv");
    for (let i = 0; i < uvAttribute.count; i++) {
        uvAttribute.setXY(i, i % 2, Math.floor(i / 4) % 2);
    }

    const linesHelper = new THREE.Mesh(geometry, material);
    linesHelper.rotation.z = 5 * (Math.PI / 4);

    const spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generatePointerTexture()),
        sizeAttenuation: false,
        depthTest: false,
    });

    const pointer = new THREE.Sprite(spriteMaterial);
    pointer.scale.set(0.015, 0.015, 1);
    pointer.renderOrder = Infinity;

    controller1 = renderer.xr.getController(0);
    controller1.name = "controller1";
    scene.add(controller1);

    controller2 = renderer.xr.getController(1);
    controller2.name = "controller2";
    scene.add(controller2);

    const controllerModelFactory = new XRControllerModelFactory();
    handModelFactory = new XRHandModelFactory();

    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(
        controllerModelFactory.createControllerModel(controllerGrip1),
    );
    scene.add(controllerGrip1);

    hand1 = renderer.xr.getHand(0);
    hand1.userData.currentHandModel = 0;
    scene.add(hand1);

    handModels.left = [handModelFactory.createHandModel(hand1, "mesh")];
    const model1 = handModels.left[0];
    model1.visible = true;
    hand1.add(model1);

    hand1.addEventListener("pinchend", function () {
        console.log("hand1 pinched");
    });

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(
        controllerModelFactory.createControllerModel(controllerGrip2),
    );
    scene.add(controllerGrip2);

    hand2 = renderer.xr.getHand(1);
    hand2.userData.currentHandModel = 2;
    scene.add(hand2);

    handModels.right = [handModelFactory.createHandModel(hand2, "mesh")];
    const model2 = handModels.right[0];
    model2.visible = true;
    hand2.add(model2);

    hand2.addEventListener("pinchend", function () {
        console.log("hand2 pinched");
    });

    window.hand1 = hand1;
    window.hand2 = hand2;

    /* rings */

    // Define the geometry and material for the wearable torus
    const torusGeometry = new THREE.TorusGeometry(0.06, 0.005, 16, 100); // Adjust the size as needed
    const torusMaterial = new THREE.MeshBasicMaterial({ color: tronLegacyColors.brightBlue }); // Green color for visibility

    controller1.addEventListener("connected", function (e) {
        console.log("Controller 1 connected!", e.data);
        if (e.data.gamepad !== null) {
            console.log("e.data.gamepad", e.data.gamepad.axes);
            if (conS.filter((obj) => obj.id === 0).length === 0) {
                conS.push({
                    id: 0,
                    data: e.data,
                });
            }
        }
    });

    controller2.addEventListener("connected", function (event) {
        console.log("Controller 2 connected!", event.data);
        if (event.data.gamepad !== null) {
            console.log("event.data.gamepad", event.data.gamepad.axes);
            if (conS.filter((obj) => obj.id === 1).length === 0) {
                conS.push({
                    id: 1,
                    data: event.data,
                });
            }
        }
    });

    controllers.push(controller1);
    controllers.push(controller2);

    controllers.forEach((controller) => {
        const simpleRayGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -10),
        ]);
        const simpleRay = new THREE.Line(
            simpleRayGeometry,
            new THREE.LineBasicMaterial({ color: 0xffffff, visible: true }),
        ); // Invisible for visual purposes
        controller.simpleRay = simpleRay; // Attach the simpleRay to the controller
        controller.add(simpleRay); // Add the simpleRay to the controller object
    });

    controllers.forEach((controller) => {
        const ray = linesHelper.clone();
        const point = pointer.clone();
        controller.add(ray, point);
        controller.ray = ray;
        controller.point = point;
    });

    const discRadius = 0.25;
    const discMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.25,
    });
    const discGeometry = new THREE.CircleGeometry(discRadius, 32);

    controllers.forEach((controller) => {
        const disc = new THREE.Mesh(discGeometry, discMaterial);
        disc.visible = false; // Initially invisible
        controller.disc = disc; // Store the disc as a property of the controller
        scene.add(disc);

        // Create and add the ring
        const ring = new THREE.Mesh(torusGeometry, torusMaterial);
        controller.ring = ring;
        ring.position.set(0, 0, 0.15); // Adjust position relative to the controller
        ring.rotation.set(0, 0, 0); // Adjust rotation if needed
        controller.add(ring); // Attach the ring directly to the controller

    });

    dummyMatrix = new THREE.Matrix4();
    raycaster = new THREE.Raycaster();

    // const geometry = new THREE.RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);
    const teleportRingGeometry = new THREE.RingGeometry(0.23, 0.25, 64);
    const teleportRingMaterial = new THREE.MeshBasicMaterial({ color: tronLegacyColors.brightBlue, side: THREE.DoubleSide });
    teleportRing = new THREE.Mesh(teleportRingGeometry, teleportRingMaterial);
    teleportRing.rotation.x = -Math.PI / 2; // Rotate to lay flat on the ground
    teleportRing.visible = false; // Initially invisible

    scene.add(teleportRing);


    cameraContainer = new THREE.Object3D();
    scene.add(cameraContainer);
    
    cameraContainer.add(camera);

    /* parent controllers to the container */
    cameraContainer.add(controller1);
    cameraContainer.add(controller2);  

    cameraContainer.add(hand1)
    cameraContainer.add(hand2)

    cameraContainer.add(model1)
    cameraContainer.add(model2)

    cameraContainer.add(controllerGrip1)
    cameraContainer.add(controllerGrip2)


    controller1.addEventListener('selectstart', function () {
        if (currentMode === 'teleportation') {
            teleportMode = true;
            activeController = controller1;
            teleportRing.visible = true;
            controller1.disc.visible = false;
        } else if (currentMode === 'weapon') {
            shootBallFromController(controller1)

        }
    });

    controller1.addEventListener('selectend', function () {
        if (currentMode === 'teleportation' && teleportMode) {
            performTeleportation();
        }
    });

    controller2.addEventListener('selectstart', function () {
        if (currentMode === 'teleportation') {
            teleportMode = true;
            activeController = controller2;
            teleportRing.visible = true;
            controller1.disc.visible = false;
        } else if (currentMode === 'weapon') {
            shootBallFromController(controller2)
        }
    });

    controller2.addEventListener('selectend', function () {
        if (currentMode === 'teleportation' && teleportMode) {
            performTeleportation();
        }
    });

    function performTeleportation() {
        if (currentMode === 'teleportation' && teleportMode && teleportRing.visible) {
            const teleportDestination = new THREE.Vector3();
            teleportRing.getWorldPosition(teleportDestination);
            cameraContainer.position.copy(teleportDestination);

            teleportMode = false;
            teleportRing.visible = false; // Hide the ring
            activeController = null;
        }
    }

}


function updateRaycasting() {

    controllers.forEach((controller) => {

        // Use the simple ray attached to the controller for raycasting
        const simpleRay = controller.simpleRay;

        // Update raycaster using simpleRay's world position and direction
        raycaster.ray.origin.setFromMatrixPosition(simpleRay.matrixWorld);
        const rayDirection = new THREE.Vector3(0, 0, -1).applyMatrix4(
            simpleRay.matrixWorld,
        );
        rayDirection.sub(raycaster.ray.origin).normalize();
        raycaster.ray.direction.copy(rayDirection);

        const intersects = raycaster.intersectObjects(objsToTest, false);

            // Perform normal raycasting
            if (intersects.length > 0) {
                const closestIntersection = intersects.reduce(
                    (closest, intersect) => {
                        return !closest || intersect.distance < closest.distance
                            ? intersect
                            : closest;
                    },
                    null,
                );

                if (closestIntersection) {
                    const intersectPoint = closestIntersection.point;
                    const intersectNormal = closestIntersection.face.normal;

                    const disc = controller.disc;

                    // Offset the disc position slightly above the intersection point
                    const offsetDistance = 0.01; // Small offset to prevent z-fighting
                    const offsetPoint = intersectPoint
                        .clone()
                        .add(intersectNormal.multiplyScalar(offsetDistance));
                    disc.position.copy(offsetPoint);

                    disc.lookAt(
                        offsetPoint.x + intersectNormal.x,
                        offsetPoint.y + intersectNormal.y,
                        offsetPoint.z + intersectNormal.z,
                    );

                    disc.visible = true;

                    teleportRing.position.copy(intersectPoint);
                    //teleportRing.position.copy(intersect.point).add(new THREE.Vector3(0, offsetHeight, 0));
                    teleportRing.position.y += 0.03

                    controller.worldToLocal(intersectPoint);
                    controller.point.position.copy(intersectPoint);
                    controller.point.visible = true;

                    // Calculate distance from the controller to the intersection point
                    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    const maxScale = 0.05; // Maximum scale
                    let scale = maxScale/distance
                    controller.point.scale.set(scale, scale, 1);
                
                }

            } else {
                if (controller.disc) {
                    controller.disc.visible = false;
                }
                controller.point.visible = false;
            }
        
    });
}


/* Teleportation / Weapon */



let currentMode = 'teleportation'; // Initial mode
const collisionThreshold = 0.12; // Threshold for ring collision, adjust as needed

let isColliding = false;
let collisionCooldown = false;
const cooldownTime = 100; // Cooldown time in milliseconds (1 second)


function startCooldown() {
    collisionCooldown = true;
    setTimeout(() => {
        collisionCooldown = false;
    }, cooldownTime);
}

function updateRingColors() {
    const newColor = (currentMode === 'teleportation') ? tronLegacyColors.brightBlue : tronLegacyColors.brightOrange; 
    controller1.ring.material.color.set(new THREE.Color(newColor));
    controller2.ring.material.color.set(new THREE.Color(newColor));

    // Toggle visibility of helper lines and points based on the current mode
    const helpersVisible = currentMode === 'weapon';
    controllers.forEach(controller => {
        controller.ray.visible = helpersVisible;
        controller.point.visible = helpersVisible;
    });
}

function getLastCharAsDigit(str) {
    if (str.length === 0) {
        return null; // or an appropriate default value
    }

    const lastChar = str.charAt(str.length - 1);
    const digit = parseInt(lastChar, 10);

    if (isNaN(digit)) {
        return null; // or handle non-digit characters as needed
    }

    return digit;
}



function switchMode() {
    currentMode = (currentMode === 'teleportation') ? 'weapon' : 'teleportation';
    updateRingColors();
    console.log("Switched to mode:", currentMode);
}

// function update() {
//     updateRaycasting();    // Existing raycasting updates
//     checkRingCollision();  // New function for checking ring collisions
// }

function checkRingCollision() {
    // Check if both controller1.ring and controller2.ring are defined
    if (controller1 && controller1.ring && controller2 && controller2.ring) {
        // Create vectors to store world positions
        const ring1WorldPosition = new THREE.Vector3();
        const ring2WorldPosition = new THREE.Vector3();

        // Get world positions of the rings
        controller1.ring.getWorldPosition(ring1WorldPosition);
        controller2.ring.getWorldPosition(ring2WorldPosition);

        // Check for ring collision using world positions
        const distance = ring1WorldPosition.distanceTo(ring2WorldPosition);

        if (distance < collisionThreshold && !isColliding && !collisionCooldown) {
            isColliding = true;
            switchMode();
            startCooldown(); // Start the cooldown period
        } else if (distance >= collisionThreshold && isColliding) {
            isColliding = false; // Rings are no longer colliding
        }
    }
}


/* Shooting balls */

function addRapierGround() {

    console.log("addRapierGround");

    let scene = playground;

    // const dracoLoader = new DRACOLoader();
    // dracoLoader.setDecoderPath('/static/libs/draco/');
    // const loader = new GLTFLoader();
    // loader.setDRACOLoader(dracoLoader);

    loader.load('{{ url_for('static', filename='models/ground.glb') }}', gltf => {
        let mesh = gltf.scene
        mesh.name = "PAD"
        mesh.ignore = true;
        scene.add(mesh);

        mesh.rotation.y = 0

        
        gltf.scene.traverse(item => {


            if (item.isMesh) {

                //console.log("isMesh:", item.name)

                const geometry = item.geometry;

                item.castShadow = true;     // allows the node to cast shadows
                item.receiveShadow = true;                 
              
                // swap material for refractions
                // item.material = new THREE.MeshPhongMaterial({ 
                //     transparent: true,  opacity: 0.1, 
                //     color: 0xFFFFFF
                //     //color: 0xFFFFFF, envMap: envMap1, refractionRatio: 0.98, reflectivity: 0.98
                // });
                
                //item.material = shaderMaterial;

                //console.log(geometry)
                const vertices = geometry.attributes.position.array;
                const indices = geometry.index.array;
                const trimesh = new RAPIER.TriMesh(vertices, indices);
                // console.log('TriMesh created successfully', trimesh);
                // console.log('Vertices length:', vertices.length);
                // console.log('Indices length:', indices.length);
                let groundColliderDesc = RAPIER.ColliderDesc.trimesh(trimesh)
                    .setDensity(100)
                    .setTranslation(0, groundHeight, 0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                // this part is a kind of hack...
                groundColliderDesc.shape.indices = indices;
                groundColliderDesc.shape.vertices = vertices;
                let groundCollider = world.createCollider(groundColliderDesc);

                window.groundColliderHandle = groundCollider.handle;
                window.myRapierWorld = world;
                window.eventQueue = eventQueue;


                item.material.wireframe = false;


                objsToTest.push(item);

            }



        })

    })


}



function shootBallFromController(controller) {

    console.log("shootBallFromController:", controller);

    // The size, density, and speed factor for the ball
    let ballSize = 0.15 + Math.random() * 0.01;
    let density = 10;
    let speedFactor = 12;

    // Get the world position of the controller
    const controllerWorldPosition = new THREE.Vector3();
    controller.getWorldPosition(controllerWorldPosition);

    // Get the world position of the point sprite
    const pointSpriteWorldPosition = new THREE.Vector3();
    controller.point.getWorldPosition(pointSpriteWorldPosition);

    // Create and shoot the ball towards the point sprite
    createAndShootBall(controllerWorldPosition, pointSpriteWorldPosition, ballSize, tronLegacyColors.brightOrange, density, speedFactor);
}



function createAndShootBall(startPosition, targetPosition, radius, color, density, speedFactor) {

    let scene = playground;

    // Calculate direction from start to target position
    let direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();

    // Create the rigid body description and set its properties
    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(startPosition.x, startPosition.y, startPosition.z)
        .setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    // Create the sphere geometry and material
    const sphereGeometry = new THREE.SphereGeometry(radius);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphereMesh.position.copy(startPosition);
    scene.add(sphereMesh);

    // Create the collider
    let colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
    myRapierWorld.createCollider(colliderDesc, rigidBody);

    // Store the rigid body and mesh for future reference
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh);
}


function logRapierEvents() {
    window.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
        //console.log("Inside drainCollisionEvents. Handle1:", handle1, "Handle2:", handle2, "Started:", started);
        
        if (handle1 === window.liftColliderHandle || handle2 === window.liftColliderHandle) {
            let ballHandle = handle1 === window.liftColliderHandle ? handle2 : handle1;
            console.log(`Monkey is involved in a collision event with ball: ${ballHandle}`);
            
            // If the collision has stopped and this ball handle hasn't been handled already
            if (!started && !window.handledBalls.includes(ballHandle)) {
                incrementPoints(ballHandle);  // Pass the ball handle to the incrementPoints function
            }
        }
    });
}



function updateRapier() {


    if (window.myRapierWorld && window.rigidBodies) {

        //window.myRapierWorld.step();
        window.myRapierWorld.step(window.eventQueue);

        //console.log(window.rigidBodies)

        for(let i = 0; i < window.rigidBodies.length; i++) {

            if(window.rigidBodies[i].bodyType() == 0) {

                let position = window.rigidBodies[i].translation();
                window.threeCubes[i].position.set(position.x, position.y, position.z);

                // Add this part to update the rotation
                let rotation = window.rigidBodies[i].rotation(); // Assuming the rotation method returns a quaternion
                window.threeCubes[i].quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        // - TO DO
        logRapierEvents()


    }
}




/* ------------------------- */
/* Camera Preseted Positions */
/* ------------------------- */

let cameraPositions = [];
import * as cameraPositionsData from './static/libs/data/cameraPositions.js'

let playground = new THREE.Scene();
playground.background = new THREE.Color(0xADD8E6); // Light blue

let magicEye = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

let magicBrush = new THREE.WebGLRenderer({antialias: true, xrCompatible: true});
magicBrush.setSize(window.innerWidth, window.innerHeight);
magicBrush.xr.enabled = true; // Enabling our magic to see in 3D (WebXR)
magicBrush.outputEncoding = THREE.sRGBEncoding;
magicBrush.gammaOutput = true;
magicBrush.gammaFactor = 1;
magicBrush.shadowMap.enabled = true;

container.appendChild(magicBrush.domElement);    

let buildingBlock = new THREE.BoxGeometry(0.2,0.2,0.2);
let colorSplash = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
let magicCube = new THREE.Mesh(buildingBlock, colorSplash);
playground.add(magicCube);

magicEye.position.set(0,1,3)

document.body.appendChild(VRButton.createButton(magicBrush));

function startPlaying() {
  magicBrush.setAnimationLoop(magicShow); // MagicShow is the ongoing fun in our playground
}

function magicShow() {

    magicCube.rotation.x += 0.01; // This line makes the MagicCube tilt up and down.
    magicCube.rotation.y += 0.01; // And this line makes it spin left and right.

    updateRapier();

    updateRaycasting();

    checkRingCollision();

    updateMixers();

    magicBrush.render(playground, magicEye);

    magicBrush.setRenderTarget(null); 


}




/* Controls */

/* Camera Positions */
const DEFAULT_CAMERA_ROT =
    '{"isEuler":true,"_x":-0.4890319918221778,"_y":0.029905380566305973,"_z":0.015910295468581418,"_order":"XYZ"}';
const DEFAULT_CAMERA_POS =
    '{"x":0.3966156804487375,"y":8.240668844853648,"z":16.11327172278412}';
const DEFAULT_CONTROLS_TARGET =
    '{"x":-1.8977369150584633,"y":-27.789645896127855,"z":-51.59438146811678}';

// ORBIT CONTROLS
const controls = new OrbitControls(magicEye, container);

controls.enableDamping = false;
//controls.dampingFactor = 0.5;
//controls.minPolarAngle = 0;
// controls.maxPolarAngle = Math.PI / 2.1; // This is already the default, means camera can't go more than 90 degrees.
controls.minDistance = 0.25; // The closest the camera can get to the target
controls.maxDistance = 900; // The farthest the camera can be from the target
const debouncedSave = debounce(saveCameraPosition, 300); // 300ms delay
controls.addEventListener("end", debouncedSave);


function debounce(func, wait) {
    let timeout;
    return function (...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}


function addHelpers(scene, camera, directionalLight) {
    // Create a new layer for helpers
    const helperLayer = new THREE.Layers();
    helperLayer.set(1); // Set to layer 1, different from the default layer 0

    // GridHelper
    const size = 500;
    const divisions = 10;
    const gridHelper = new THREE.GridHelper(size, divisions, 0x333333, 0xFFFFFF00);
    gridHelper.layers.enable(1); // Assign to layer 1
    gridHelper.ignore = true
    gridHelper.position.set(0,-0.01,0)
    // scene.add(gridHelper);

    // CameraHelper
    // const cameraHelper = new THREE.CameraHelper(camera);
    // cameraHelper.layers.enable(1); // Assign to layer 1
    // cameraHelper.ignore = true;
    // scene.add(cameraHelper);

    // DirectionalLightHelper
    const dirLightHelperSize = 1;
    const dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, dirLightHelperSize);
    dirLightHelper.layers.enable(1); // Assign to layer 1
    dirLightHelper.ignore = true;
    //scene.add(dirLightHelper);

    // Create an AxesHelper
    const axesHelper = new THREE.AxesHelper(100); // 5 is the size of the axes
    axesHelper.ignore = true;
    playground.add(axesHelper);

}



function addLights() {

// light
    const hemilight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 3);
    playground.add(hemilight);


    const light = new THREE.DirectionalLight(0xe6ffff, 3);
    playground.add(light);

    light.position.set(-20, 20, -20);
    light.castShadow = true;
    light.shadow.camera.left = -5;
    light.shadow.camera.right = 5;
    light.shadow.camera.top = 5;
    light.shadow.camera.bottom = -5;
    light.shadow.camera.near = 0.3;
    light.shadow.camera.far = 512;
    light.shadow.mapSize.set(256 * 10, 256 * 10);
    light.shadow.radius = 1;

    addHelpers(playground, magicEye, light)
  
}

addLights() 




// function createGradientTexture() {
//     const size = 512; // Size of the texture
//     const canvas = document.createElement('canvas');
//     canvas.width = size;
//     canvas.height = size;

//     const context = canvas.getContext('2d');
//     const gradient = context.createRadialGradient(
//         canvas.width / 2,
//         canvas.height / 2,
//         0,
//         canvas.width / 2,
//         canvas.height / 2,
//         canvas.width / 2
//     );

//     // Define your gradient colors and stops
//     gradient.addColorStop(0, 'rgba(173, 216, 230, 1)'); // Light blue
//     gradient.addColorStop(1, 'rgba(255, 255, 255, 1)'); // White

//     context.fillStyle = gradient;
//     context.fillRect(0, 0, canvas.width, canvas.height);

//     return new THREE.CanvasTexture(canvas);
// }

function addGradientBackground() {


    let sphereGeometry = new THREE.SphereGeometry(500, 120, 80);
    sphereGeometry.scale(-1, 1, 1); // Invert the sphere to make its surface visible from the inside

    // Canvas

    // // let gradientTexture = new THREE.TextureLoader().load('path/to/gradient.jpg'); // Load your gradient texture
    // const gradientTexture = createGradientTexture();
    // let sphereMaterial = new THREE.MeshBasicMaterial({ map: gradientTexture });
    // playground.background = gradientTexture;

    // let sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    // playground.add(sphere);


    // SVG
    // const svgString = `
    // <svg width="512" height="512" xmlns="http://www.w3.org/2000/svg">
    //     <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
    //         <stop offset="0%" style="stop-color:rgb(173,216,230);stop-opacity:1" />
    //         <stop offset="100%" style="stop-color:rgb(255,255,255);stop-opacity:1" />
    //     </radialGradient>
    //     <ellipse cx="256" cy="256" rx="256" ry="256" style="fill:url(#grad1)" />
    // </svg>`;

    // Shader
    const vertexShader = `
        varying vec2 vUvRainbow;
        void main() {
            vUvRainbow = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const fragmentShader = `

        precision highp float;

        uniform float rainbowTime;
        varying vec2 vUvRainbow;

        vec3 interpolateColor(float hue) {
                
            // Sunset Sky
            vec3 sunsetSkyTopColor = vec3(1.0, 0.4, 0.1);
            vec3 sunsetSkyBotColor = vec3(1.0, 0.6, 0.6);

            // // Ocean Depth
            vec3 oceanDepthTopColor = vec3(0.0, 0.5, 0.7);
            vec3 oceanDepthBotColor = vec3(0.2, 0.8, 0.8);

            // // Forest Canopy
            vec3 forestCanopyTopColor = vec3(0.13, 0.55, 0.13);
            vec3 forestCanopyBotColor = vec3(0.56, 0.74, 0.56);

            // // Desert Dusk
            vec3 desertDuskTopColor = vec3(0.5, 0.3, 0.5);
            vec3 desertDuskBotColor = vec3(0.9, 0.7, 0.5);

            // // Arctic Aurora
            vec3 arcticAuroraTopColor = vec3(0.05, 0.31, 0.55);
            vec3 arcticAuroraBotColor = vec3(0.2, 0.8, 0.9);

            // Interpolate between colors
            if (hue < 0.5) {
                // Blend between bottom and middle colors in the lower half
                return mix(desertDuskTopColor, desertDuskBotColor, hue * 2.0);
            } else {
                // Blend between middle and top colors in the upper half
                return mix(sunsetSkyBotColor, sunsetSkyTopColor, (hue - 0.5) * 2.0);
            }


        }

        float dither(vec2 position) {
            float ditherPattern = fract(sin(dot(position.xy, vec2(12.9898,78.233))) * 43758.5453);
            return ditherPattern;
        }

        void main() {

            float hue = mod(vUvRainbow.y - rainbowTime * 0.99, 1.0);
            vec3 color = interpolateColor(hue);

            // Apply dithering
            float ditherValue = dither(gl_FragCoord.xy);
            color = mix(color, color * 0.97, ditherValue);

            gl_FragColor = vec4(color, 1.0);

        }



    `;

    const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader
    });

    //const svgTexture = new THREE.TextureLoader().load('data:image/svg+xml;base64,' + window.btoa(svgString));
    //let sphereMaterial = new THREE.MeshBasicMaterial({ map: material });
    let sphere = new THREE.Mesh(sphereGeometry, material);
    playground.add(sphere);
    sphere.ignore = true;    


}


/* Exporters */


function exportSceneToGLB(fileName = 'scene.glb') {
    let scene = playground;
    const exporter = new GLTFExporter();

    // Parse the input and generate the glTF output
    exporter.parse(
        scene,
        function (gltf) {
            saveArrayBuffer(gltf, fileName);
        },
        {
            binary: true, // For GLB output
            // Include additional options if necessary
        }
    );
}

function saveArrayBuffer(data, fileName) {
    const a = document.createElement('a');
    document.body.appendChild(a);
    a.style.display = 'none';

    const blob = new Blob([data], { type: 'application/octet-stream' });
    const url = window.URL.createObjectURL(blob);

    a.href = url;
    a.download = fileName;
    a.click();

    window.URL.revokeObjectURL(url);
}
window.exportSceneToGLB = exportSceneToGLB;


/* Camera Positions */

function saveCameraPosition() {
    let camera = magicEye;
    const cameraData = {
        position: camera.position.clone(),
        rotation: camera.rotation.clone(),
    };
    const controlsData = { target: controls.target.clone() };
    // Store individual data (optional based on your use case)
    localStorage.setItem("cameraData", JSON.stringify(cameraData));
    localStorage.setItem("controlsData", JSON.stringify(controlsData));
    // Store combined data
    cameraPositions.push({ camera: cameraData, controls: controlsData });
    localStorage.setItem("cameraPositions", JSON.stringify(cameraPositions));
    // console.log(JSON.stringify(cameraPositions[cameraPositions.length - 1]));
}

function restoreCameraPosition() {
  let camera = magicEye;
    try {
        if (localStorage.getItem("cameraPositions") && camera) {
            let data = JSON.parse(localStorage.getItem("cameraPositions"));
            let cam = data[data.length - 1].camera;
            let con = data[data.length - 1].controls;
            camera.position.copy(new THREE.Vector3().copy(cam.position));
            camera.rotation.set(cam.rotation.x, cam.rotation.y, cam.rotation.z);
            if (controls) {
                controls.target.copy(new THREE.Vector3().copy(con.target));
            }
        } else {
            // Use the default values if no data is available in localStorage
            camera.position.copy(
                new THREE.Vector3().fromJSON(JSON.parse(DEFAULT_CAMERA_POS)),
            );
            let defaultRot = JSON.parse(DEFAULT_CAMERA_ROT);
            camera.rotation.set(defaultRot._x, defaultRot._y, defaultRot._z);
            if (controls) {
                controls.target.copy(
                    new THREE.Vector3().fromJSON(
                        JSON.parse(DEFAULT_CONTROLS_TARGET),
                    ),
                );
            }
        }
        controls.update();
    } catch (error) {
        console.error("Error restoring camera position:", error);
    }
}



/* LIL GUI */

let gui;
let objectList = {};

function initializeGUI() {
    if (gui) {
        gui.destroy(); // Destroy the existing GUI
    }
    gui = new GUI();
    objectList = {};
}

initializeGUI(); // Initialize the GUI


function recreateGUI() {
    // Store data, destroy the existing GUI, and create a new one
    const data = storeGUIState();
    gui.destroy();
    gui = new lil.GUI();
    restoreGUIState(data);
}


function removeGuiForObject(object) {
    const fileName = object.userData.fileName;
    if (fileName && objectList[fileName]) {
        // Attempt to remove the folder's DOM element
        const folder = objectList[fileName];
        if (folder.domElement && folder.domElement.parentNode) {
            folder.domElement.parentNode.removeChild(folder.domElement);
        }

        // Safely delete the folder from gui.__folders
        if (gui.__folders && gui.__folders[fileName]) {
            delete gui.__folders[fileName];
        }

        // Remove the folder from the object list
        delete objectList[fileName];
    }
}



function restoreGUIState(guiState) {
    for (const folderName in guiState.values) {
        if (folderName in gui.__folders) {
            let folder = gui.__folders[folderName];

            for (const propName in guiState.values[folderName]) {
                let control = folder.__controllers.find(c => c.property === propName);
                if (control) {
                    control.setValue(guiState.values[folderName][propName]);
                }
            }

            if (guiState.openFolders.includes(folderName)) {
                folder.open();
            } else {
                folder.close();
            }
        }
    }
}



function addGuiForObject(object) {
    if (!objectList[object.userData.fileName]) {
        const folder = gui.addFolder(object.userData.fileName);
        const data = {
            remove: () => {
                removeGuiForObject(object);
                playground.remove(object);
                //saveScene(); // Update the saved scene after removal
            }
        };
        folder.add(data, 'remove').name('Remove [x]');
        objectList[object.userData.fileName] = folder;
    }
    // Update existing folder if necessary
}



// function saveScene() {

//     console.log("saveScene");

//     const sceneObjects = [];

//     // Traverse and save objects, create GUI entries if they don't exist
//     playground.traverse((object) => {
//         if (object.userData.fileName) {
//             if (!objectList[object.userData.fileName]) {
//                 // Only create a new GUI folder if it doesn't exist
//                 addGuiForObject(object);
//             }
//             console.log("object.userData.fileName", object.userData.fileName);
//             sceneObjects.push({
//                 fileName: object.userData.fileName,
//                 position: object.position.toArray(),
//                 rotation: object.rotation.toArray(),
//                 scale: object.scale.toArray()
//             });
//         }
//     });

//     localStorage.setItem('scene', JSON.stringify(sceneObjects));

// }



// function saveScene() {
//     console.log("saveScene");
//     const sceneObjects = [];

//     // Check if gui.__folders is a valid object
//     if (gui && gui.__folders && typeof gui.__folders === 'object') {
//         Object.keys(gui.__folders).forEach(folderName => {
//             if (objectList[folderName]) {
//                 const folder = objectList[folderName];
//                 if (folder && folder.domElement && folder.domElement.parentNode) {
//                     folder.domElement.parentNode.removeChild(folder.domElement);
//                 }
//                 delete gui.__folders[folderName];
//             }
//         });
//     }
//     objectList = {};

//     playground.traverse((object) => {
//         if (object.userData.fileName) {
//             addGuiForObject(object);
//             console.log("object.userData.fileName", object.userData.fileName);
//             sceneObjects.push({
//                 fileName: object.userData.fileName,
//                 position: object.position.toArray(),
//                 rotation: object.rotation.toArray(),
//                 scale: object.scale.toArray()
//             });
//         }
//     });

//     localStorage.setItem('scene', JSON.stringify(sceneObjects));
// }


function modelTree(model) {
   model.traverse((object) => {
    console.log(object)
  });   
}
window.modelTree = modelTree;


function loadScene() {
    const savedScene = localStorage.getItem('scene');
    if (savedScene) {
        initializeGUI(); // Re-initialize the GUI
        const sceneObjects = JSON.parse(savedScene);

        const dracoLoader = new DRACOLoader();

        // '{{ url_for('static', filename='libs/rapier3d-compat/rapier.es.js') }}';

        dracoLoader.setDecoderPath('/static/libs/draco/');

        sceneObjects.forEach((obj) => {
            const modelPath = './models/' + encodeURIComponent(obj.fileName);
            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);

            loader.load(modelPath, (gltf) => {
                let model = gltf.scene;
                model.position.fromArray(obj.position);
                model.rotation.fromArray(obj.rotation);
                model.scale.fromArray(obj.scale);
                model.userData.fileName = obj.fileName;
                playground.add(model);
                addGuiForObject(model); // Add GUI entry for the loaded object













            }, undefined, (error) => {
                console.error('An error happened while loading a model:', error);
            });
        });
    }
}



// Drag and Drop setup
document.body.ondragover = (event) => event.preventDefault();

// document.body.ondrop = (event) => {
//     event.preventDefault();

//     let file = event.dataTransfer.files[0];
//     if (file) {
//         // Split the filename by dots and get the last part as the extension
//         let parts = file.name.split('.');
//         let extension = parts[parts.length - 1].toLowerCase();

//         if (extension === 'glb' || extension === 'gltf') {
//             loadModel(file, event.clientX, event.clientY);
//         } else {
//             alert('Please drop a .glb or .gltf file.');
//         }
//     }
// };

const pseudoID = () => ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
  (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
);

function generateUuid() {
    let id = new Date().getTime() + "--" + pseudoID()
    return id;
}

let clientID = localStorage.getItem('clientID');
if (!clientID) {
    clientID = generateUuid();  // Implement this function to generate a UUID
    localStorage.setItem('clientID', clientID);
}


// Function to convert base64 string to ArrayBuffer
function base64ToArrayBuffer(base64) {
    const binaryString = window.atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

function checkConnectionHealth() {
    if (lastPingTimestamp && (Date.now() - lastPingTimestamp > MAX_PING_DELAY)) {
        console.warn("WebSocket connection might be unhealthy or disconnected.");
        // Implement reconnection or alert logic here
    } else {
        console.log("WebSocket connection is healthy.");
    }
}

function strSize(base64String) {
    return parseFloat((Math.ceil(base64String.length * 0.75) / 1048576).toFixed(2));
}




let ws;
let conHealth;
const PING_INTERVAL = 15000;
let lastPingTimestamp = null;
const RECONNECT_INTERVAL = 60000;
let ws_debug = false;

function connectWebSocket() {
    const protocol = (window.location.protocol === 'https:') ? 'wss://' : 'ws://';
    const host = window.location.hostname;
    const wsUrl = protocol + host + ':5000';

    console.log("wsUrl:", wsUrl);

    ws = new WebSocket(wsUrl);

    ws.onopen = function() {
        console.log("WebSocket connection established");
        ws.send(JSON.stringify({ type: 'register', uuid: clientID }));
        conHealth = setInterval(checkConnectionHealth, PING_INTERVAL);
    };


    ws.onmessage = function (event) {

        const data = JSON.parse(event.data);

        // console.log("WS: onmessage:");

        if(ws_debug) {

            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    if (typeof data[key] === 'object' && data[key] !== null) {
                        // Handling objects - convert to string or iterate over properties
                        console.log(`\t${key}:`, JSON.stringify(data[key], null, '\t'));
                    } else if (key === "type") {
                        // Styling specific property
                        console.log(`\t%c${key}: ${data[key]}`, "color: blue;");
                    } else {
                        // Default log for non-object properties

                        
                        if(key === "data") {
                            let size = strSize(data[key])
                            console.log(`\t${key}: size: %c${size}`, 'color: red');
                        } else {
                            console.log(`\t${key}: ${data[key]}`);
                        }

                    }
                }
            }

        }

        //console.log(" WS: data.type", data.type)


        // if (data.type === 'clientDisconnected') {
        //     console.log("ws: clientDisconnected: ", data.client_id, data.clients);
        // }

        if (data.type === 'modelData') {
            const blob = new Blob([base64ToArrayBuffer(data.data)], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            const url_uuid = data.url_uuid
            
            loadModel(url, data.pos, url_uuid);
        }

        if (data.type === 'newModelData') {
            const blob = new Blob([base64ToArrayBuffer(data.data)], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            const url_uuid = data.url_uuid            
            loadNewModel(url, data.pos, url_uuid);
        }



        if (data.type === 'newModel') {

            console.log(`%cnew Model to add!`+data.uuid,"color: red");

             requestModel(data.uuid, data.position);


        }


        // if (data.type === 'broadcast') {
        //     console.log("ws: broadcast: ", data.content, data.clients);
        // }    

        // if (data.type === 'roomUpdate') {
        //     console.log("ws: roomUpdate: ", data.clients);
        // }

        // if (data.type === 'ping') {
        //     lastPingTimestamp = Date.now();
        // }

        if (data.command === 'reload') {
            window.location.reload();
        }

        if (data.type === 'existingModels') {

            console.log("\texistingModels, data.models:",data.models.length)

            data.models.forEach((model, index) => {

                console.log('\t\t'+index + '\t' + model.uuid);


              if(playground.getObjectByName(model.uuid) == undefined) {

                    console.log("\t\tmodel.uuid - load it:", model.uuid)
                    requestModel(model.uuid, model.position);
              
              }  else {

                    console.log("\t\tmodel.uuid - exist")


              }


            })

            // data.models.forEach(model => {
            //     // Load each model into the scene

            //     if(playground.getObjectByName(model.uuid) == undefined) {
            //         requestModel(model.uuid, model.position);
            //         console.log("existingModels + model.uuid - ",model.uuid, " - loading - ")
            //     } else {
            //         console.log("existingModels - model.uuid - ",model.uuid, " - exists - ")
            //     }
            // });
        }

        if (data.type === 'modelRemoved') {
            console.log("modelRemoved: data.uuid",data.uuid)
           playground.remove(playground.getObjectByName(data.uuid))
        }


    };


    ws.onerror = function(error) {
        console.error('WebSocket Error:', error);
    };

    ws.onclose = function() {
        console.log("WebSocket connection closed. Attempting to reconnect...");
        clearInterval(conHealth);  // Stop the health check
        setTimeout(connectWebSocket, RECONNECT_INTERVAL); // Attempt to reconnect
    };

}

connectWebSocket()


function broadcastNewModel(uuid, pos) {
    console.log(" ---> broadcastNewModel", uuid)
    const message = {
        type: "broadcastNewModel",
        uuid: uuid,
        pos: pos
    };
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
    } else {
        console.error('WebSocket is not open. Cannot request the model.');
    }
}


function requestNewModel(uuid, pos) {
    console.log(" ---> requestModel", uuid)
    const message = {
        type: "requestNewModel",
        uuid: uuid,
        pos: pos
    };
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
    } else {
        console.error('WebSocket is not open. Cannot request the model.');
    }
}


function requestModel(uuid, pos) {
    console.log(" ---> requestModel", uuid)
    const message = {
        type: "requestModel",
        uuid: uuid,
        pos: pos
    };
    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
    } else {
        console.error('WebSocket is not open. Cannot request the model.');
    }
}

function findTopMostParent(obj) {
    let currentObject = obj;
    // Traverse up the hierarchy until you find an object whose parent is the scene (playground)
    while (currentObject.parent && currentObject.parent !== playground) {
        currentObject = currentObject.parent;
    }
    return currentObject.name;  // This should be the UUID of the root group
}


function findRootObjectName(obj) {
    let currentObj = obj;
    while (currentObj.parent) {
        currentObj = currentObj.parent;
    }
    return currentObj.name;
}


let clock = new THREE.Clock()
let mixers = [];
function updateMixers() {
    let delta = clock.getDelta();
    for (let i = 0; i < mixers.length; i++) {
        mixers[i].update(delta);
    }
}

function loadModel(file, pos, url_uuid) {
    console.log(" ---> requestModel", url_uuid);

    let position = JSON.parse(pos);
    console.log("position", position);

    loader.load(
        file,
        function (gltf) {  // onSuccess callback
            let model = gltf.scene;

            let modelGroup = new THREE.Group();
            modelGroup.position.copy(position);
            modelGroup.add(model);
            modelGroup.name = url_uuid;
            playground.add(modelGroup);

            console.log("loadModel, name", modelGroup.name);

           // Handle animations
            if (gltf.animations && gltf.animations.length) {
                // Create a mixer and add it to the mixers array
                let mixer = new THREE.AnimationMixer(modelGroup);
                mixers.push(mixer);

                // Add all animations to the mixer
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });
            }            

        },
        undefined, 
        function (error) { 
            console.error('Error loading model:', error);
        }
    );
}


function loadNewModel(file, pos, url_uuid) {
    console.log(" ---> requestModel", url_uuid);

    let position = JSON.parse(pos);
    console.log("position", position);

    loader.load(
        file,
        function (gltf) {  // onSuccess callback
            let model = gltf.scene;

            let modelGroup = new THREE.Group();
            modelGroup.position.copy(position);
            modelGroup.add(model);
            modelGroup.name = url_uuid;
            playground.add(modelGroup);

            console.log("loadNewModel, name", modelGroup.name);

            broadcastNewModel(url_uuid, pos)

           // Handle animations
            if (gltf.animations && gltf.animations.length) {
                // Create a mixer and add it to the mixers array
                let mixer = new THREE.AnimationMixer(modelGroup);
                mixers.push(mixer);

                // Add all animations to the mixer
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });
            }


        },
        undefined, 
        function (error) { 
            console.error('Error loading model:', error);
        }
    );
}



//             broadcastNewModel(url,data.pos, url_uuid)






document.body.ondrop = (event) => {

    event.preventDefault();

    let x = event.clientX;
    let y = event.clientY;

    // Convert screen coordinates (x, y) to 3D space coordinates
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, magicEye);

    let intersects = raycaster.intersectObjects(playground.children, true);
    let point = intersects[0].point;
    let pointData = { x: point.x, y: point.y, z: point.z };
    let pointString = JSON.stringify(pointData);    


    let file = event.dataTransfer.files[0];
    if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
        let formData = new FormData();
        formData.append('file', file);
        formData.append('uploader', localStorage.getItem('clientID'));
        formData.append('position', pointString);

        fetch('/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            console.log('Upload successful', data);
            console.log("pointString", pointString)
            requestNewModel(data.uuid, `${pointString}`)
        })
        .catch(error => console.error('Error:', error));
    } else {
        alert('Please drop a .glb or .gltf file.');
    }
};



function onWindowResize() {
  let camera = magicEye;
  let renderer = magicBrush;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}


/*

    ----------------------

*/

let isGrabMode = false;
let grabbedObject = null;

// Create a plane geometry and material
let planeGeometry = new THREE.PlaneGeometry(100, 100);
let planeMaterial = new THREE.MeshBasicMaterial({ color: 0xafeeee, side: THREE.DoubleSide, transparent: true, opacity: 1, wireframe: true });
let visualPlane = new THREE.Mesh(planeGeometry, planeMaterial);
visualPlane.isVisualPlane = true;
playground.add(visualPlane);

// Assuming you have a Three.js scene set up
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

let selectedObject = null;
let outlineObject = null;

let grabSphere;


function initGrabSphere() {
    let sphereGeometry = new THREE.SphereGeometry(4, 64, 64);
    let sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.1, wireframe: false });
    grabSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    grabSphere.visible = false;
    playground.add(grabSphere);

    visualPlane.visible = false;
}


function recreateOutlineObject(object) {
    if (outlineObject && outlineObject.parent) {
        playground.remove(outlineObject);
    }

    outlineObject = object.clone(true);
    outlineObject.isOutline = true;

    // Apply world transformations to the outlineObject
    const worldPosition = new THREE.Vector3();
    const worldQuaternion = new THREE.Quaternion();
    const worldScale = new THREE.Vector3();
    object.matrixWorld.decompose(worldPosition, worldQuaternion, worldScale);

    outlineObject.position.copy(worldPosition);
    outlineObject.quaternion.copy(worldQuaternion);
    outlineObject.scale.copy(worldScale).multiplyScalar(1.012);

    outlineObject.material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.25 });

    outlineObject.name = object.parent.parent.name;

    console.log("outlineObject.name:",outlineObject.name)

    playground.add(outlineObject);
}



function onMouseClick(event) {

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, magicEye);

    // const intersects = raycaster.intersectObjects(playground.children, true)
    //                             .filter(intersect => !intersect.object.isOutline && !intersect.object.isVisualPlane && !intersect.object.ignore);
    const intersects = raycaster.intersectObjects(playground.children, true)
                                 .filter(intersect => {
                                     let obj = intersect.object;
                                     while (obj) {
                                         if (obj.isOutline || obj.isVisualPlane || obj.ignore) {
                                             return false;
                                         }
                                         obj = obj.parent;
                                     }
                                     return true;
                                 });



    if (isGrabMode) {

        isGrabMode = false;
        grabbedObject = null;
        visualPlane.visible = false;
        grabSphere.visible = false;
        
        // outlineObject.visible = false;

        // recreateOutlineObject(selectedObject);
        return;
    }

    if (intersects.length > 0) {

        if (!isGrabMode) {
            grabbedObject = intersects[0].object; // Assign grabbedObject here
        }

        if (outlineObject) {
            playground.remove(outlineObject);
            outlineObject = null;
        }

        selectedObject = intersects[0].object;
        outlineObject = selectedObject.clone(true);
        outlineObject.name = findTopMostParent(selectedObject)
        outlineObject.isOutline = true;

        if (selectedObject.parent && selectedObject.parent !== playground) {
            outlineObject.applyMatrix4(selectedObject.parent.matrixWorld);
        }

        outlineObject.scale.multiplyScalar(1.012);
        outlineObject.material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.25, wireframe: true });

        const worldPosition = new THREE.Vector3();
        selectedObject.getWorldPosition(worldPosition);

        const cameraDirection = new THREE.Vector3();
        magicEye.getWorldDirection(cameraDirection);
        visualPlane.position.copy(worldPosition);
        visualPlane.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), cameraDirection.negate());

        playground.add(outlineObject);
    } else {
        if (outlineObject) {
            playground.remove(outlineObject);
            outlineObject = null;
        }
    }
}


let isDrawMode = false;
let currentLine = null;
let linePoints = [];
let lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
let lineGeometry = new THREE.BufferGeometry();


let distanceLine = 10; // Set your desired distance


function getMousePositionIn3D(event) {
    let camera = magicEye;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);

    // Create a plane parallel to the camera at the specified distance
    const planeNormal = new THREE.Vector3();
    const planePoint = new THREE.Vector3();
    camera.getWorldDirection(planeNormal);
    planePoint.copy(camera.position).add(planeNormal.multiplyScalar(distanceLine));
    const plane = new THREE.Plane();
    plane.setFromNormalAndCoplanarPoint(planeNormal, planePoint);

    // Calculate the intersection point
    const intersection = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, intersection);
    return intersection;
}


document.addEventListener('mouseup', (event) => {

    if (isDrawMode) {
        // Finalize drawing
        isDrawMode = false;
        controls.enabled = true;
        if (currentLine) {
            playground.add(currentLine);
            currentLine = null;
            linePoints = [];
            //saveScene();
        }
    }


    if (isGrabMode) {
        // Exiting grab mode
        isGrabMode = false;
        grabbedObject = null;
        visualPlane.visible = false;
        grabSphere.visible = false;

        // Additional logic (if any) to finalize object position
        // ...

        // Update or recreate the outlineObject to reflect the new position
        if (selectedObject) {
            recreateOutlineObject(selectedObject);
        }

        //saveScene()
    }
});



document.addEventListener('mousedown', (event) => {

    if (isDrawMode) {
        currentLine = new THREE.Line(new THREE.BufferGeometry(), lineMaterial);
        const intersectPoint = getMousePositionIn3D(event);
        if (intersectPoint) {
            linePoints = [intersectPoint.clone()];
            currentLine.geometry.setFromPoints(linePoints);
            playground.add(currentLine);
        }
    }

    if (outlineObject) {
        console.log(outlineObject)
    }

});



document.addEventListener('mousemove', (event) => {


    if (isDrawMode) {
        // Drawing logic
        if (!currentLine) return;
        
        const intersectPoint = getMousePositionIn3D(event);
        if (intersectPoint) {
            linePoints.push(intersectPoint.clone());
            currentLine.geometry.setFromPoints(linePoints);
            currentLine.geometry.attributes.position.needsUpdate = true;
        }
    }



    if (isGrabMode && grabSphere.visible) {

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, magicEye);
        const planeNormal = new THREE.Vector3(0, 0, 1).applyQuaternion(visualPlane.quaternion);
        const plane = new THREE.Plane();
        
        plane.setFromNormalAndCoplanarPoint(planeNormal, visualPlane.position);
        
        const intersectPoint = new THREE.Vector3();
        
        if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
            grabSphere.position.copy(intersectPoint);

            if (grabbedObject) {
                if (grabbedObject.parent) {
                    // Convert the intersect point to the local coordinate system of the grabbedObject's parent
                    const localIntersectPoint = grabbedObject.parent.worldToLocal(intersectPoint.clone());
                    grabbedObject.position.copy(localIntersectPoint);
                } else {
                    // If the grabbedObject has no parent, simply copy the position
                    grabbedObject.position.copy(intersectPoint);
                }
            }
        }

        if (outlineObject) {
            const worldPosition = new THREE.Vector3();
            selectedObject.getWorldPosition(worldPosition);
            outlineObject.position.copy(worldPosition);
        }


    }

});

/* Keys - keyboard */
function updatePosition(direction, shiftMultiplier, normalMultiplier) {
    let t = playground.getObjectByName(outlineObject.name)
    const movementScale = shiftMultiplier ? 0.1 : normalMultiplier;
    t.position.addScaledVector(direction, movementScale);
    outlineObject.position.copy(t.position)
}

function changeScale(isIncreasing) {
    let t = playground.getObjectByName(outlineObject.name)
    const scaleMultiplier = isIncreasing ? 1.03 : 0.96;
    t.scale.multiplyScalar(scaleMultiplier);        
    outlineObject.scale.copy(t.scale).multiplyScalar(1.012);
}

function rotateObject() { 
    const q = new THREE.Quaternion();
    q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0.1);
    console.log("rotateObject: - selectedObject.parent", selectedObject.parent)
    let t = playground.getObjectByName(outlineObject.name)
    t.quaternion.premultiply(q);
    outlineObject.quaternion.premultiply(q);
}


/* 
    Blender - like camera position and rotation reset 

*/

function setCameraPosition(number) {
    let camera = magicEye;
    let targetPosition = new THREE.Vector3();

    // Get the world position of the selected object or default to the origin
    if (selectedObject) {
        selectedObject.getWorldPosition(targetPosition);

        // Get the bounding box of the selected object to calculate its height
        const boundingBox = new THREE.Box3().setFromObject(selectedObject);
        const size = new THREE.Vector3();
        boundingBox.getSize(size);
        const halfHeight = size.y / 2;
        
        // Adjust the Y position of the camera to half the height of the object for side views
        if ([1, 3, 4, 6].includes(number)) { // Front, right, left, back views
            targetPosition.y += halfHeight;
        }
    } else {
        targetPosition.set(0, 0, 0);
    }

    // Calculate the distance from the camera to the target position
    let dist = camera.position.distanceTo(targetPosition);

    // Decrease distance to 2 if it's more than 3 and an object is selected
    if (selectedObject && dist >= 6) {
        dist = 6;
    }

    switch (number) {
        case 1: // Front view
            camera.position.set(targetPosition.x, targetPosition.y, targetPosition.z + dist);
            break;
        case 2: // Bottom view
            camera.position.set(targetPosition.x, targetPosition.y - dist, targetPosition.z);
            break;
        case 3: // Right view
            camera.position.set(targetPosition.x + dist, targetPosition.y, targetPosition.z);
            break;
        case 4: // Left view
            camera.position.set(targetPosition.x - dist, targetPosition.y, targetPosition.z);
            break;
        case 5: // User-defined or reset view
            // Define this based on your requirements
            break;
        case 6: // Back view
            camera.position.set(targetPosition.x, targetPosition.y, targetPosition.z - dist);
            break;
        case 7: // Top view
            camera.position.set(targetPosition.x, targetPosition.y + dist, targetPosition.z);
            break;
        // Add more cases as needed
    }

    // Update the camera to look at the target position
    camera.lookAt(targetPosition);
    camera.updateProjectionMatrix();

    // Update controls to orbit around the new target
    controls.target.copy(targetPosition);
    controls.update();

    // Optionally save the camera position if required
    saveCameraPosition();
}



function createCube() {
    // Geometry
    var geometry = new THREE.BoxGeometry(1, 1, 1);

    // Material - using MeshBasicMaterial with default color
    var material = new THREE.MeshBasicMaterial();

    // Mesh - combining geometry and material
    var cube = new THREE.Mesh(geometry, material);

    return cube;
}






/* 

    Grab Mode

    */

function toggleGrabMode() {
    isGrabMode = !isGrabMode;
    visualPlane.visible = isGrabMode;
    grabSphere.visible = isGrabMode;

    if (!isGrabMode) {
        grabbedObject = null;
    } else if (selectedObject) {
        // Update the grabSphere position based on the selectedObject's world position
        const worldPosition = new THREE.Vector3();
        selectedObject.getWorldPosition(worldPosition);
        grabSphere.position.copy(worldPosition);
    }
}


function duplicateObject(shiftKeyPressed) {
    if (shiftKeyPressed) {

        //
        
        if(selectedObject.parent.type == 'Group') {
            const newObject = selectedObject.parent.clone(true);
            //const newGroup = new THREE.Group();
            playground.add(newObject);
            randomizeTransform(newObject);
        }

        console.log("selectedObject.parent:",selectedObject.parent.type)
        // const newObject = selectedObject.clone(true);
        // const newGroup = new THREE.Group();
        // newGroup.add(newObject);
        // newGroup.userData = selectedObject.parent.userData;
        // playground.add(newGroup);
        // randomizeTransform(newGroup);
        // console.log("cloning");
        // saveScene();
    }
}

function removeObject() {

    // if(selectedObject.parent) {
    //     selectedObject = selectedObject.parent;
    // }
    
    let uuid

    if (outlineObject && outlineObject.parent) {
        outlineObject.parent.remove(outlineObject);
    }

    uuid = outlineObject.name; //findTopMostParent(selectedObject)    
    outlineObject = null;
    
    if (selectedObject.parent) {
        selectedObject.parent.remove(selectedObject);
    } else {
        playground.remove(selectedObject);
    }

    console.log("removeObject uuid", uuid)

    ws.send(JSON.stringify({
        type: 'removeModel',
        uuid: uuid
    }));


    selectedObject = null;



    //saveScene();
}

function randomizeTransform(group) {


    group.position.set(Math.random() * 20 - Math.random() * 20, Math.random() * 20 - Math.random() * 20, Math.random() * 20 - Math.random() * 20);
    // group.rotation.set(Math.random() * 3.14, Math.random() * 3.14, Math.random() * 3.14);
    // group.scale.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);


}


let shiftPressed = false;
let aPressed = false;
function catchCreateCube() {


    if (event.key === 'Shift') {
        shiftPressed = true;
    }

    // Check for 'A' key
    if (event.key === 'a' || event.key === 'A') {
        aPressed = true;
    }

    // Check for 'C' key and if SHIFT and A were pressed
    if ((event.key === 'c' || event.key === 'C') && shiftPressed && aPressed) {
        playground.add(createCube());
        console.log("createCube", "catchCreateCube");
        //saveScene();
    }
}




document.addEventListener('keydown', (event) => {


    if (event.key >= '0' && event.key <= '9') {
        setCameraPosition(parseInt(event.key));
    }


    if (event.key === 'l' || event.key === 'L') {
        
        isDrawMode = !isDrawMode;
        controls.enabled = !isDrawMode;

        if (!isDrawMode && currentLine) {
            // Finalize and save the current line
            playground.add(currentLine);
            currentLine = null;
            linePoints = [];
            //saveScene();
        }
    }


    if (!selectedObject) return;

    const forward = new THREE.Vector3();
    magicEye.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const strafe = new THREE.Vector3();
    strafe.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    if (event.key.toLowerCase() === 'g') {
        toggleGrabMode();
    }


    catchCreateCube();


    switch (event.key) {
        case 'd':
        case 'D':
            duplicateObject(event.shiftKey);
            break;
        case 'ArrowUp':
            updatePosition(new THREE.Vector3(0, 1, 0), event.shiftKey, forward.length());
            break;
        case 'ArrowDown':
            updatePosition(new THREE.Vector3(0, -1, 0), event.shiftKey, -forward.length());
            break;
        case 'ArrowLeft':
            updatePosition(strafe, false, -0.1);
            break;
        case 'ArrowRight':
            updatePosition(strafe, false, 0.1);
            break;
        case 's':
        case 'S':
            changeScale(!event.shiftKey);
            break;
        case 'r':
        case 'R':
            rotateObject();
            break;
        case 'x':
        case 'X':
            removeObject();
            break;
    }

    if (selectedObject) {
        const worldPosition = new THREE.Vector3();
        selectedObject.getWorldPosition(worldPosition);
        outlineObject.position.copy(worldPosition);
    }
});


window.playground = playground

// Add event listener for mouse clicks
document.addEventListener('click', onMouseClick);

window.addEventListener('resize', onWindowResize);

restoreCameraPosition();

loadScene();

initGrabSphere();

addGradientBackground();  

startPlaying();


async function initRapier() {

    await RAPIER.init();

    world = new RAPIER.World(gravity);
    eventQueue = new RAPIER.EventQueue(true);


    addRapierGround();


    initControllers()
    
}




document.addEventListener("DOMContentLoaded", function() {

    initRapier()

    document.getElementById("main-body").style.visibility = "visible";
    document.getElementById("main-body").style.opacity = 1;


});



</script>

</body>

</html>



